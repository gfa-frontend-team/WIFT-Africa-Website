# Optimization Plan: Post Functionality & Media Upload

## 1. Executive Summary
The current system handles posts and uploads but faces scalability and functionality limitations:
- **Uploads**: Currently rely on local disk storage ([src/middleware/upload.ts](file:///Users/khalidsalman-yusuf/Documents/Unleashified/Active/WIFT-Africa-Backend/src/middleware/upload.ts)), which is not scalable or suitable for cloud deployments (e.g., Vercel, Heroku, Docker). There is **no support for video uploads** in the current middleware.
- **Posts**: The feed uses offset-based pagination (`skip/limit`) which can cause duplicate/missed items in active feeds. There is no dedicated endpoint for uploading post media.
- **Performance**: Heavy database queries with multiple `populate` calls are performed on every feed request without caching.

This plan outlines a roadmap to robust, scalable, and high-performance post and media handling.

---

## 2. Media Upload Optimization (Images & Videos)

### Current State
- **Storage**: Local filesystem (`uploads/`).
- **Middleware**: `multer` with disk storage.
- **Limitations**:
  - No video support (only images/docs allowed).
  - No image compression/resizing.
  - No dedicated endpoint for "Post Media".
  - Not ephemeral-filesystem friendly.

### Proposed Architecture: Cloud-Based Media Service
**Goal**: Move to **Cloudinary** (already in [package.json](file:///Users/khalidsalman-yusuf/Documents/Unleashified/Active/WIFT-Africa-Backend/package.json)) or AWS S3 for storage.

#### A. New Upload Module
Create a unified `UploadService` that handles:
1.  **Direct Upload vs Server Proxy**:
    - *Option A (Recommended for Video)*: Generate **Signed URLs** so the frontend uploads directly to Cloudinary/S3. This saves server bandwidth and CPU.
    - *Option B (Simpler)*: Server-side upload stream (Client -> Server -> Cloudinary). Easier to implement but heavier on the server.
2.  **File Processing**:
    - **Images**: Auto-convert to WebP, valid sizes (thumbnail, medium, large).
    - **Videos**: Transcoding for streaming (HLS/dash) or standard mp4 optimization.

#### B. Implementation Steps
1.  **Configure Cloudinary**: Set up `src/config/cloudinary.ts`.
2.  **Create Upload Controller**:
    - `POST /api/v1/uploads/sign`: Get a signed URL for direct upload (User ID metadata included).
    - `POST /api/v1/uploads/media`: (Legacy/Fallback) Multipart upload via server.
3.  **Update Database Models**:
    - Ensure `media` fields store the full Cloudinary URL and `public_id` (for deletion).

---

## 3. Post Functionality Optimization

### Current State
- **Pagination**: `page`/`limit` (Offset-based).
- **Feed Logic**: Complex `$or` query ([Public](file:///Users/khalidsalman-yusuf/Documents/Unleashified/Active/WIFT-Africa-Backend/src/modules/users/users.controller.ts#259-277), [Chapter](file:///Users/khalidsalman-yusuf/Documents/Unleashified/Active/WIFT-Africa-Backend/src/services/post.service.ts#426-447), `Connections`) + Multiple Populates (`author`, `originalPost`, `originalPost.author`).
- **Missing**: No generic media upload flow. The [createPost](file:///Users/khalidsalman-yusuf/Documents/Unleashified/Active/WIFT-Africa-Backend/src/services/post.service.ts#37-58) endpoint expects URLs to already exist.

### Proposed Optimizations

#### A. Cursor-Based Pagination
Switch from `page/limit` to **Cursor-based** (using `_id` or `createdAt`).
- **Why**: Prevents "shifting" content (duplicate/missed posts) when new posts are added while a user is scrolling.
- **How**: Client sends `lastPostId`. Server queries `_id < lastPostId`.

#### B. Redis Caching for Feeds
- **Public Feed**: The "Public" portion of the feed is the same for everyone. Cache the top 50-100 public posts in Redis.
- **User Specifics**: Merge cached public posts with lightweight queries for "Connections" and "Chapter" posts.

#### C. Database Indexing
Ensure valid Compound Indexes exist to satisfy the `$or` queries efficiently:
```typescript
// Proposed Index for Feed
postSchema.index({ isDeleted: 1, visibility: 1, createdAt: -1 });
postSchema.index({ targetChapters: 1, createdAt: -1 });
```

#### D. Background Processing (Queues)
Use a message queue (e.g., BullMQ with Redis) for heavy write operations:
- **Notification Fan-out**: When a user with 10k followers posts, don't create 10k notifications in the request loop. Offload to a background worker.
- **Video Processing**: If doing server-side video, offload encoding to a background job.

---

## 4. Profile Optimization

### Current State
- `users/me/profile-photo` uploads to local disk.

### Proposed Changes
- **Avatar Optimization**: When uploading a profile photo, generate a standard 400x400 WebP version. Store this Optimized URL.
- **Caching**: Cache user profiles (`users:profile:{id}`) in Redis with a TTL (e.g., 1 hour) or invalidate on update.

---

## 5. Recommended Roadmap

### Phase 1: Storage Infrastructure (High Priority)
1. [ ] Configure Cloudinary/S3 Service.
2. [ ] Create `UploadService` with methods for Image and Video handling.
3. [ ] Create independent `UploadController` ( `POST /api/v1/uploads` ).
4. [ ] Enable Video upload support (mime-type validation).

### Phase 2: Post & Feed Upgrade
1. [ ] Update [createPost](file:///Users/khalidsalman-yusuf/Documents/Unleashified/Active/WIFT-Africa-Backend/src/services/post.service.ts#37-58) to optionally handle media upload or validate media URLs.
2. [ ] Refactor [getPostsFeed](file:///Users/khalidsalman-yusuf/Documents/Unleashified/Active/WIFT-Africa-Backend/src/services/post.service.ts#337-414) to use **Cursor-based Pagination**.
3. [ ] Optimize Database Indexes.

### Phase 3: Performance & Caching
1. [ ] Implement Redis caching for "Public Feed".
2. [ ] Implement Redis caching for "User Profiles".

---

## 6. Code Examples

### A. Cloudinary Configuration
```typescript
import { v2 as cloudinary } from 'cloudinary';

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET
});

export const removeFile = async (publicId: string) => {
    return cloudinary.uploader.destroy(publicId);
};
```

### B. Cursor Pagination Logic
```typescript
// Incoming query: ?cursor=65a1b2c3d4e5...
const cursor = req.query.cursor;
const query = {
  ...filters,
  ...(cursor && { _id: { $lt: cursor } }) // Get posts OLDER than the cursor
};
const posts = await Post.find(query).sort({ _id: -1 }).limit(limit);
const nextCursor = posts.length ? posts[posts.length - 1]._id : null;
```
